/*
134. 加油站.cpp

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

*/

/*
题解：
有点像最大子序和，数组成员为gas[i]-cost[i]，可能摆动（值为正负）
不同点在于是个环路，求的是起始下标

画个图

剩余油量
|   /\
|  /  \/\        /
| /      \    /\/
0---------\--/-------位置
|          \/

要能跑一圈，前提是总gas > 总cost
在这个前提下只需要找到起始下标，使每个位置剩余油量都不能为负
如果有负的，从下一个位置重新计算
如果总gas < 总cost，返回-1，这个可以单独遍历得到
优化一下，可以在搜索下标一起计算：
把从开始位置的负油量之和保存，只要最后剩余油量扣除总负油量为正，说明满足总gas > 总cost
*/

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    	// 加油站起始点
        int start = 0;
        // 从0-start总共需要补充多少油 
        int need = 0;
        // 从start开始到i的剩余油量，可能为正负，正：剩余，负：还要补充多少油   
        int remain = 0;

        for(int i = 0; i < gas.size(); i++) {
        	// remain有两种情况：
            // 走过ith 加油站还剩下多少油（>0）
            // 要走ith 加油站差多少油（<0）
            remain += gas[i] - cost[i];
            // 油不够了，start不能做起始点；  
            // 且start ～ i 都不可做起始点 (贪心：局部排除)  
            // 可以反证，假设0~i的某个位置i-k可以，那么i-k到i剩余油量为正，  
            // 那么0~k的总剩余油量一定为负，否则到位置i不会为负，这和i是首个为负有矛盾。  
            if(remain < 0) { //如果走不到i
            	//记录要补的油的总量（可能有多个i要补）  
                need += remain;
                //从下一个位置继续搜索，复位剩余油量为0  
                start = i+1;
                remain = 0;
            }
        }
        //走到最后，如果剩余油量-需要补的油量>0，说明可以从头开始，走完之前缺油断掉的路  
        //此时start位置出发就满足走一圈的条件  
        //否则找不到能走一圈的位置  
        return need+remain >= 0 ? start : -1;
    }
};