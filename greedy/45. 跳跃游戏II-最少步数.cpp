/*
45. 跳跃游戏 II.cpp
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置

说明:假设你总是可以到达数组的最后一个位置
*/


/*
思路：
每次都跳最远，总次数是不是最少？
不一定，每步最远不一定全局步数最少，可能有步数跳近一点，下一次反而跳更远的情况。
如：[13241111], 按每步最远是131111，实际可以1341
从3跳到2,4,1都是一步，假如局部就是[13241]，跳到最远位置就是最优选择
但在4处，最远距离更新了(局部数据改变)，为了步数最少，必定是从4直接跳到此时刻最远位置（当前局部最优）
所有有如下规律：
在当前最远距离的下标范围内，如果有最远距离更新，则选择走更新发生时的那个下标，再一步走到新的最远距离，这是局部最优
事实上我们不需要关注每次走哪个下标，关注的是，什么时候更新最远距离，同时更新步数
用变量rtag存储当前位置i的最远位置，range存储后续迭代过程中的实时最远距离
向后遍历，如果位置i+k更新的range > rtag，最远距离更新了，此时找到局部最优了吗？
不一定，如果i+k+1又更新了range，且i+k+1在也rtag范围内，
根据之前的例子，跳到最远范围内任意位置都是一步，因此选择i+k+1能走到更大的range,相对来讲就是步数更少
因此需要延迟更新，一定要i遍历到rtag才能确定下一次跳的位置，然后步数+1

递推如下：
遍历整个数组，在每次遍历内：
*在每个位置尝试更新最远位置
*当下标和最远位置重合，更新步数+1，同时记录下一个最远位置

贪婪算法，求什么就贪什么，本题不能贪每步最远，而是贪每次最远距离有更新时的局部情况，到最远距离的步数最少


*/
class Solution {
public:
    int jump(vector<int>& nums) {
    	int range = 0; //当前时刻最远位置，每次循环都尝试更新
    	int rtag = 0; //range tag，记录上次标记的最远距离
    	int cnt = 0;
    	for (int i = 0; i < nums.size()-1; ++i) 
    	{
    		range = max(i + nums[i], range);
    		if (i == rtag)
    		{	
    			cnt++;
    			rtag = range;
    		} 
    	}
    	return cnt;
    }
};